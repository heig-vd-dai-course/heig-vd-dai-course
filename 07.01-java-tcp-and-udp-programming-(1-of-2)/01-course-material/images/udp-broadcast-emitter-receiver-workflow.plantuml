@startuml udp-broadcast-emitter-receiver-workflow
skinparam boxPadding 100
skinparam maxMessageSize 300
skinparam noteTextAlignment center
skinparam sequenceMessageAlign direction
skinparam wrapWidth 250
autonumber

!pragma teoz true

!$TITLE = "UDP - Broadcast (emitter/receiver) workflow"
!$MULTIPAGE = 0

!if ($MULTIPAGE)
    right footer $TITLE (%page%/%lastpage%)
    !pragma teoz false
!else
    ignore newpage
!endif

title $TITLE

participant "Emitter\n(192.168.1.25)" as emitter
participant "Node 1\n(192.168.1.23)" as node1
participant "Node 2\n(192.168.1.24)" as node2

== Create the receiver sockets ==

node1 -> node1 : **Create** a socket and **bind** it to a port (e.g. ""4445"")\n(class ""DatagramSocket"")

/ note right node2
    You might notice that //Node 2// has not created a socket/decided to receive any datagram on the node.

    However, the node is on the same network as the others.
endnote

newpage $TITLE

== Create the emitter socket and datagram ==

emitter -> emitter : **Create** a socket\n(class ""DatagramSocket"")

emitter -> emitter : **Set** the socket to broadcast mode\n(method ""socket.setBroadcast(true)"")

emitter -> emitter : **Get/transform** the data to send as an array of bytes\n(method depending on the type of data)

emitter -> emitter : **Create** a datagram packet using the broadcast address and port (e.g. ""192.168.1.255"" and ""4445"")\n(class ""DatagramPacket"")

newpage $TITLE

== Send and receive datagrams ==

loop Receiver side: loop until socket is closed

    node1 -> node1 : **Wait to receive** a datagram packet on the given socket\n(method ""socket.receive()"")

    note over emitter, node1
        At this point, the socket will wait for a datagram to arrive on the given port.
    endnote

    ...

    note over emitter, node1
        At any time, the emitter can decide to send the datagram packet.

        The datagram packet will be forwarded to the broadcast network using the information contained in the datagram header (broadcast's network, sender's IP, etc.).
    endnote

    note over emitter, node2
        At this point, the datagram will be sent to all nodes on the network, no matter if the nodes want/listen to the given port.
    endnote

    emitter -> node1 : **Send** the datagram on the network\n(method ""socket.send(packet)"")

    autonumber stop

    & emitter -> node2

    autonumber resume

    emitter -> emitter : **Close** the connection\n(method ""socket.close()"")

    node1 -> node1 : **Receive** the datagram packet\n(method ""socket.receive()"")

    / note right node2
        You might notice //Node 2// still receives the datagram on its network interface, even though it never asked for it.
    endnote
    
    node2 -> node2 : **Ignore** the datagram packet

    node1 -> node1 : **Get/transform** the datagram packet payload\n(method depending on the type of data)

    note over emitter, node1
        The receiver will loop back to receive another datagram.
    endnote

end

newpage $TITLE

...

== Receiver shutdown ==

note over emitter, node1
    On shutdown, the receiver can close its datagram socket.
endnote

node1 -> node1 : **Close** the connection\n(method ""socket.close()"")
@enduml
